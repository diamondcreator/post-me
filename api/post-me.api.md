## API Report File for "post-me"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class BareMessenger implements Messenger {
    // Warning: (ae-forgotten-export) The symbol "Postable" needs to be exported by the entry point index.d.ts
    constructor(postable: Postable);
    // Warning: (ae-forgotten-export) The symbol "MessageListener" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ListenerRemover" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    addMessageListener: (listener: MessageListener) => ListenerRemover;
    // (undocumented)
    postMessage: (message: any, transfer?: Transferable[]) => void;
}

// @public
export type CallOptions = {
    transfer?: Transferable[];
};

// Warning: (ae-forgotten-export) The symbol "MethodsType" needs to be exported by the entry point index.d.ts
//
// @public
export function ChildHandshake<M extends MethodsType>(messenger: Messenger, localMethods?: M): Promise<Connection>;

// Warning: (ae-forgotten-export) The symbol "EventsType" needs to be exported by the entry point index.d.ts
//
// @public
export class ConcreteEmitter<E extends EventsType> implements Emitter<E> {
    constructor();
    addEventListener<K extends keyof E>(eventName: K, listener: (data: E[K]) => void): void;
    // @internal (undocumented)
    protected emit<K extends keyof E>(eventName: K, data: E[K]): void;
    once<K extends keyof E>(eventName: K): Promise<E[K]>;
    // @internal (undocumented)
    protected removeAllListeners(): void;
    removeEventListener<K extends keyof E>(eventName: K, listener: (data: E[K]) => void): void;
}

// @public
export interface Connection<M0 extends MethodsType = any, E0 extends EventsType = any, M1 extends MethodsType = any, E1 extends EventsType = any> {
    close(): void;
    localHandle(): LocalHandle<M0, E0>;
    remoteHandle(): RemoteHandle<M1, E1>;
}

// @public
export function debug(namespace: string, log?: (...data: any[]) => void): (...data: any[]) => void;

// @public
export function DebugMessenger(messenger: Messenger, log?: (...data: any[]) => void): Messenger;

// @public
export type EmitOptions = {
    transfer?: Transferable[];
};

// @public
export interface Emitter<E extends EventsType> {
    addEventListener<K extends keyof E>(eventName: K, listener: (data: E[K]) => void): void;
    once<K extends keyof E>(eventName: K): Promise<E[K]>;
    removeEventListener<K extends keyof E>(eventName: K, listener: (data: E[K]) => void): void;
}

// @public
export interface LocalHandle<M extends MethodsType = any, E extends EventsType = any> {
    emit<K extends keyof E>(eventName: K, data: E[K], options?: EmitOptions): void;
    setEmitTransfer<K extends keyof E>(eventName: K, transfer: (payload: E[K]) => Transferable[]): void;
    // Warning: (ae-forgotten-export) The symbol "InnerType" needs to be exported by the entry point index.d.ts
    setReturnTransfer<K extends keyof M>(methodName: K, transfer: (result: InnerType<ReturnType<M[K]>>) => Transferable[]): void;
}

// @public
export interface Messenger {
    addMessageListener(listener: MessageListener): ListenerRemover;
    postMessage(message: any, transfer?: Transferable[]): void;
}

// @public
export function ParentHandshake<M0 extends MethodsType>(messenger: Messenger, localMethods?: M0, maxAttempts?: number, attemptsInterval?: number): Promise<Connection>;

// @public
export class PortMessenger extends BareMessenger implements Messenger {
    constructor({ port }: {
        port: MessagePort;
    });
}

// @public
export interface RemoteHandle<M extends MethodsType = any, E extends EventsType = any> extends Emitter<E> {
    call<K extends keyof M>(methodName: K, ...args: Parameters<M[K]>): Promise<InnerType<ReturnType<M[K]>>>;
    customCall<K extends keyof M>(methodName: K, args: Parameters<M[K]>, options?: CallOptions): Promise<InnerType<ReturnType<M[K]>>>;
    setCallTransfer<K extends keyof M>(methodName: K, transfer: (...args: Parameters<M[K]>) => Transferable[]): void;
}

// @public
export class WindowMessenger implements Messenger {
    constructor({ localWindow, remoteWindow, remoteOrigin, }: {
        localWindow?: Window;
        remoteWindow: Window;
        remoteOrigin: string;
    });
    // (undocumented)
    addMessageListener: (listener: MessageListener) => ListenerRemover;
    // (undocumented)
    postMessage: (message: any, transfer?: Transferable[]) => void;
}

// @public
export class WorkerMessenger extends BareMessenger implements Messenger {
    constructor({ worker }: {
        worker: Worker;
    });
}


```
